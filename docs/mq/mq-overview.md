# Message Queue

## 简介

**Message Queue**：消息队列，即MQ



消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。

消息队列（Message Queue）是一种应用间的通信方式。消息队列是典型的 *生产者-消费者* 模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。

![image-20211112161717225](img/image-20211112161717225.png)



## 消息队列的作用

1. **解耦**

   如图所示，假设有系统B、C、D都需要系统A的数据，于是系统A调用三个方法发送数据到B、C、D。这时，系统D不需要了，那就需要在系统A把相关的代码删掉。假设这时有个新的系统E需要数据，这时系统A又要增加调用系统E的代码。为了降低这种强耦合，就可以使用MQ，系统A只需要把数据发送到MQ，其他系统如果需要数据，则从MQ中获取即可。通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。

   ![img](img/image-20211112161554428.png)

2. **异步**

   如图所示，一个客户端请求发送进来，系统A会调用系统B、C、D三个系统，同步请求的话，响应时间就是系统A、B、C、D的总和，也就是800ms。如果使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能。对于一些非必要的业务，比如发送短信，发送邮件等等，就可以采用这种方式。

   只有在业务流程允许异步处理的情况下才能这么做。比如在注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。

   ![image-20211112161832548](img/image-20211112161832548.png)

3. **削峰**，通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。

   如图所示，这其实是MQ一个很重要的应用。假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL对于如此庞大的请求当然处理不过来，MySQL就会崩溃，导致系统瘫痪。

   如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃。

   ![image-20211112162014339](img/image-20211112162014339.png)

> 💡 `发布-订阅模式`是 **JMS 规范** 两种消息模型中的一种，另外 **AMQP 协议** 还提出了五种消息模型，见下文。



## 使用消息队列带来的问题

- **系统可用性降低：** 在加入MQ之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入MQ之后你就需要去考虑了；
- **系统复杂性提高：** 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题；
- **一致性问题：** 消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息，就会导致数据不一致的情况。



## 消息模型

### JMS 两种消息模型

JMS（JAVA Message Service, java消息服务）是 java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。JMS API 是一个消息服务的标准或者说是规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。***ActiveMQ* 就是基于 JMS 规范实现的。**

**JMS 定义了五种不同的消息正文格式，以及调用的消息类型**，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性：

- `StreamMessage `：Java原始值的数据流
- `MapMessage`：一套名称-值对
- `TextMessage`：一个字符串对象
- `ObjectMessage`：一个序列化的 Java对象
- `BytesMessage`：一个字节的数据流



#### 点对点模型 P2P

**一个生产者向一个特定的队列发布消息，只有一个消费者从该队列中读取消息**。

生产者不需要在接收者消费该消息期间处于运行状态，接收者也同样不需要在消息发送时处于运行状态；每一个成功处理的消息都由接收者签收；多个消费者对于队列内的消息是竞争消费关系，每个消费者只能收到队列中的一部分消息。

![](img/20201124141849.png)



#### 发布/订阅模型 Pub/Sub

**一个生产者向一个特定的队列发布消息，0 个或多个订阅者可以接受来自特定消息主题的消息**。

发布者需要创建一个 `订阅主题（Topic）` 以便客户能够购订阅并保持持续的活动以接受消息，**一个订阅主题是由至少一个队列（Queue）组成的，除非订阅者创建了持久的订阅，在订阅者未连接时发布的消息将在订阅者重新连接时重新发布**，每个消费者都能收到全量的消息。

![](img/20201124141856.png)



### AMQP 五种消息模型

**AMQP**，即 Advanced Message Queuing Protocol，一个提供统一消息服务的**应用层**标准——**高级消息队列协议**（二进制应用层协议），是应用层协议的一个开放标准, 为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。***RabbitMQ* 就是基于 AMQP 协议实现的。**

AMQP  提供了五种消息模型：

- **direct exchange**
- **fanout exchange**
- **topic change**
- **headers exchange**
- **system exchange**

本质来讲，后四种和 JMS 的 *Pub/Sub* 模型没有太大差别，仅是在路由机制上做了更详细的划分。



### JMS vs AMQP

| 对比方向     | JMS                                      | AMQP                                                         |
| ------------ | ---------------------------------------- | ------------------------------------------------------------ |
| 定义         | Java API                                 | 协议                                                         |
| 跨语言       | 否                                       | 是                                                           |
| 跨平台       | 否                                       | 是                                                           |
| 支持消息类型 | 提供两种消息模型：①Peer-2-Peer；②Pub/sub | 提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分。 |
| 支持消息类型 | 支持 5 种消息类型                        | `byte[]`（二进制）                                           |

**总结：**

- **AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范**。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。
- JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 `byte[]` 消息类型（复杂的类型可序列化后发送）。
- 由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。



## 常见的消息队列对比

- ActiveMQ：基于JMS
- RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好
- RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会
- Kafka：分布式消息系统，高吞吐量

| 特性                     | ActiveMQ                              | RabbitMQ                                           | RocketMQ                                                     | Kafka                                                        |
| ------------------------ | ------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单机吞吐量               | 万级，比 RocketMQ、Kafka 低一个数量级 | 同 ActiveMQ                                        | 10 万级，支撑高吞吐                                          | 10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |
| topic 数量对吞吐量的影响 |                                       |                                                    | topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic | topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源 |
| 时效性                   | ms 级                                 | 微秒级，这是 RabbitMQ 的一大特点，延迟最低         | ms 级                                                        | 延迟在 ms 级以内                                             |
| 可用性                   | 高，基于主从架构实现高可用            | 同 ActiveMQ                                        | 非常高，分布式架构                                           | 非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
| 消息可靠性               | 有较低的概率丢失数据                  | 基本不丢                                           | 经过参数优化配置，可以做到 0 丢失                            | 同 RocketMQ                                                  |
| 功能支持                 | MQ 领域的功能极其完备                 | 基于 erlang 开发，并发能力很强，性能极好，延时很低 | MQ 功能较为完善，还是分布式的，扩展性好                      | 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 |

**总结：**

- **ActiveMQ** 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，**不推荐使用**。

- **RabbitMQ** 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。

  👍 **如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，*RabbitMQ*一定是你的首选。**

  👍 **如果是大数据领域的实时计算、日志采集等场景，用 *Kafka* 是业内标准的，绝对没问题**，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。

- **RocketMQ** 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险.

- **kafka** 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性，天然适合大数据实时计算以及日志收集。



## 📚 资料

- **RabbitMQ**
  - [RabbitMQ 官网](https://www.rabbitmq.com/)
- **Kafka**
  - [Kafka Github](https://github.com/apache/kafka)
  - [Kafka 官网](http://kafka.apache.org/)
  - [Kafka 官方文档](https://kafka.apache.org/documentation/)
  - [Kafka 中文文档](https://github.com/apachecn/kafka-doc-zh)

- ActiveMQ
  - [ActiveMQ 官网](http://activemq.apache.org/)



## 参考文献

- [doocs.gitee.io/advanced-java](https://doocs.gitee.io/advanced-java/#/./docs/distributed-system/distributed-system-interview)
- [gitee@veal98/CS-Wiki](gitee/v)

