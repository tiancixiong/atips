"use strict";(self.webpackChunkatips=self.webpackChunkatips||[]).push([[8640],{5862:(e,n,t)=>{t.r(n),t.d(n,{data:()=>r});const r={key:"v-4c998775",path:"/java/concurrent/java-concurrent-locks-ReentrantLock.html",title:"JUC锁 - ReentrantLock",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"java/concurrent/java-concurrent-locks-ReentrantLock.md",git:{updatedTime:1635671824e3,contributors:[{name:"TianCi.Xiong",email:"tiancixiong@163.com",commits:1}]}}},8483:(e,n,t)=>{t.r(n),t.d(n,{default:()=>u});var r=t(6252);const a=(0,r._)("h1",{id:"juc锁-reentrantlock",tabindex:"-1"},[(0,r._)("a",{class:"header-anchor",href:"#juc锁-reentrantlock","aria-hidden":"true"},"#"),(0,r.Uk)(" JUC锁 - ReentrantLock")],-1),c=(0,r._)("blockquote",null,[(0,r._)("p",null,"可重入锁 ReentrantLock 的底层是通过 AQS(AbstractQueuedSynchronizer) 实现")],-1),o=(0,r._)("p",null,[(0,r._)("strong",null,"重入锁"),(0,r.Uk)("：一个线程获得了锁之后仍然可以"),(0,r._)("strong",null,"反复"),(0,r.Uk)("的加锁，不会出现自己阻塞自己的情况。")],-1),l={},u=(0,t(3744).Z)(l,[["render",function(e,n){return(0,r.wg)(),(0,r.iD)(r.HY,null,[a,c,o],64)}]])},3744:(e,n)=>{n.Z=(e,n)=>{for(const[t,r]of n)e[t]=r;return e}}}]);