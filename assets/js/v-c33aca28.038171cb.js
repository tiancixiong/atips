"use strict";(self.webpackChunkatips=self.webpackChunkatips||[]).push([[9034],{7051:(e,n,s)=>{s.r(n),s.d(n,{data:()=>a});const a={key:"v-c33aca28",path:"/software/vcs/git-flight-rules.html",title:"Git 飞行规则",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:'什么是"飞行规则"?',slug:"什么是-飞行规则",children:[]},{level:2,title:"编辑提交(editting commits)",slug:"编辑提交-editting-commits",children:[{level:3,title:"我刚才提交了什么?",slug:"我刚才提交了什么",children:[]},{level:3,title:"commit message写错了",slug:"commit-message写错了",children:[]},{level:3,title:"commit中的用户名和邮箱不对",slug:"commit中的用户名和邮箱不对",children:[]},{level:3,title:"我想从一个提交(commit)里移除一个文件",slug:"我想从一个提交-commit-里移除一个文件",children:[]},{level:3,title:"删除任意提交",slug:"删除任意提交",children:[]}]},{level:2,title:"暂存(Staging)",slug:"暂存-staging",children:[{level:3,title:"把暂存的内容添加到上一次的提交",slug:"把暂存的内容添加到上一次的提交",children:[]},{level:3,title:"只暂存一个新文件的一部分",slug:"只暂存一个新文件的一部分",children:[]},{level:3,title:"撤销暂存的内容，恢复到工作区",slug:"撤销暂存的内容-恢复到工作区",children:[]}]},{level:2,title:"未暂存(Unstaged)的内容",slug:"未暂存-unstaged-的内容",children:[{level:3,title:"把未暂存的内容移动到一个新分支",slug:"把未暂存的内容移动到一个新分支",children:[]},{level:3,title:"把未暂存的内容移动到另一个已存在的分支",slug:"把未暂存的内容移动到另一个已存在的分支",children:[]},{level:3,title:"丢弃本地未提交的变化(uncommitted changes)",slug:"丢弃本地未提交的变化-uncommitted-changes",children:[]},{level:3,title:"丢弃某些未暂存的内容",slug:"丢弃某些未暂存的内容",children:[]}]},{level:2,title:"分支(Branches)",slug:"分支-branches",children:[{level:3,title:"我从错误的分支拉取了内容，或把内容拉取到了错误的分支",slug:"我从错误的分支拉取了内容-或把内容拉取到了错误的分支",children:[]}]},{level:2,title:"变基(rebase)和合并(merge)",slug:"变基-rebase-和合并-merge",children:[{level:3,title:"我想撤销rebase/merge",slug:"我想撤销rebase-merge",children:[]},{level:3,title:"我已经rebase过, 但是我不想强推(force push)",slug:"我已经rebase过-但是我不想强推-force-push",children:[]},{level:3,title:"检查是否分支上的所有提交(commit)都合并(merge)过了",slug:"检查是否分支上的所有提交-commit-都合并-merge-过了",children:[]},{level:3,title:"交互式rebase(interactive rebase)可能出现的问题",slug:"交互式rebase-interactive-rebase-可能出现的问题",children:[]}]},{level:2,title:"Stash",slug:"stash",children:[{level:3,title:"暂存所有改动",slug:"暂存所有改动",children:[]},{level:3,title:"暂存指定文件",slug:"暂存指定文件",children:[]}]},{level:2,title:"杂项",slug:"杂项",children:[{level:3,title:"克隆所有子模块",slug:"克隆所有子模块",children:[]},{level:3,title:"恢复已删除标签(tag)",slug:"恢复已删除标签-tag",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",children:[]}],filePathRelative:"software/vcs/git-flight-rules.md",git:{updatedTime:1701927383e3,contributors:[{name:"TianCi.Xiong",email:"tiancixiong@163.com",commits:1},{name:"Tianci.Xiong",email:"tiancixiong@163.com",commits:1}]}}},7396:(e,n,s)=>{s.r(n),s.d(n,{default:()=>N});var a=s(6252);const t=(0,a.uE)('<h1 id="git-飞行规则" tabindex="-1"><a class="header-anchor" href="#git-飞行规则" aria-hidden="true">#</a> Git 飞行规则</h1><h2 id="什么是-飞行规则" tabindex="-1"><a class="header-anchor" href="#什么是-飞行规则" aria-hidden="true">#</a> 什么是&quot;飞行规则&quot;?</h2><blockquote><p><em>飞行规则(Flight Rules)</em> 是记录在手册上的来之不易的一系列知识，记录了某个事情发生的原因，以及怎样一步一步的进行处理。本质上, 它们是特定场景的非常详细的标准处理流程。</p></blockquote><h2 id="编辑提交-editting-commits" tabindex="-1"><a class="header-anchor" href="#编辑提交-editting-commits" aria-hidden="true">#</a> 编辑提交(editting commits)</h2><h3 id="我刚才提交了什么" tabindex="-1"><a class="header-anchor" href="#我刚才提交了什么" aria-hidden="true">#</a> 我刚才提交了什么?</h3><p>当你想快速知道上一次 commit 提交了哪些内容。可以通过以下命令显示当前 <code>HEAD</code> 上的最近一次提交：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> show\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>或者：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> log -n1 -p\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="commit-message写错了" tabindex="-1"><a class="header-anchor" href="#commit-message写错了" aria-hidden="true">#</a> commit message写错了</h3><p>场景：上一次提交信息（commit message）写错了，需要修改 message。</p><p>修改最近一次 commit 的 message 信息：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> commit --amend --only\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>上面命令会进入 vi 编辑页面进行修改，加上 <code>-m [new message]</code> 可以一次完成：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> commit --amend --only -m <span class="token string">&quot;新的信息&quot;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div>',15),i=(0,a.Uk)("如果需要修改多个 commit message，可以参考"),l={href:"https://blog.xiongtianci.com/2019/11/12/Git%E4%BF%AE%E6%94%B9%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84commit%E6%B3%A8%E9%87%8A/",target:"_blank",rel:"noopener noreferrer"},c=(0,a.Uk)("Git修改已提交的commit注释"),r=(0,a.Uk)("。"),p=(0,a.uE)('<h3 id="commit中的用户名和邮箱不对" tabindex="-1"><a class="header-anchor" href="#commit中的用户名和邮箱不对" aria-hidden="true">#</a> commit中的用户名和邮箱不对</h3><p>场景：上一次进行提交时，作者信息是错误的，导致 commit 中的作者信息（姓名和邮箱）有误。想将其修改成正确的信息。</p><p>只修改最近一次提交，使用以下命令：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> commit --amend --no-edit --author <span class="token string">&quot;Name &lt;email&gt;&quot;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>邮箱需使用 <code>&lt;&gt;</code> 括住。另一种方式是先将全局变量修正后再进行修改，如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 第一步：设置全局变量</span>\n$ <span class="token function">git</span> config --global user.name <span class="token string">&quot;Author Name&quot;</span>\n$ <span class="token function">git</span> config --global user.email <span class="token string">&quot;Author Email&quot;</span>\n\n<span class="token comment"># 第二步：重置作者信息（作者时间戳也会被更新）</span>\n$ <span class="token function">git</span> commit --amend --reset-author --no-edit\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>如果你需要更改所有历史记录，请参考 <code>git filter-branch</code>。</p><h3 id="我想从一个提交-commit-里移除一个文件" tabindex="-1"><a class="header-anchor" href="#我想从一个提交-commit-里移除一个文件" aria-hidden="true">#</a> 我想从一个提交(commit)里移除一个文件</h3>',8),o={href:"https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md#%E6%88%91%E6%83%B3%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%8F%90%E4%BA%A4commit%E9%87%8C%E7%A7%BB%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6",target:"_blank",rel:"noopener noreferrer"},d=(0,a.Uk)("TODO"),u=(0,a._)("h3",{id:"删除任意提交",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#删除任意提交","aria-hidden":"true"},"#"),(0,a.Uk)(" 删除任意提交")],-1),m={class:"custom-container warning"},h=(0,a._)("p",{class:"custom-container-title"},"注意",-1),b=(0,a.Uk)("此操作使用 "),g={href:"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA",target:"_blank",rel:"noopener noreferrer"},v=(0,a.Uk)("变基"),k=(0,a.Uk)(" 实现，请谨慎使用。"),f=(0,a._)("strong",null,"如果 commit 已经 push 了，而别人可能基于这些提交进行开发，那么不要执行变基！",-1),x=(0,a.uE)('<div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> rebase --onto base from to\n$ <span class="token function">git</span> push -f <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>使用 <code>--onto</code> 之后, 后面会跟3个参数（<code>git rebase --onto base from to</code>）。意思是使用 (from, to] 所指定的范围内的所有 commit 在 base 这个 commit 之上进行重建。</p></blockquote><h2 id="暂存-staging" tabindex="-1"><a class="header-anchor" href="#暂存-staging" aria-hidden="true">#</a> 暂存(Staging)</h2><h3 id="把暂存的内容添加到上一次的提交" tabindex="-1"><a class="header-anchor" href="#把暂存的内容添加到上一次的提交" aria-hidden="true">#</a> 把暂存的内容添加到上一次的提交</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> commit --amend\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="只暂存一个新文件的一部分" tabindex="-1"><a class="header-anchor" href="#只暂存一个新文件的一部分" aria-hidden="true">#</a> 只暂存一个新文件的一部分</h3>',6),E=(0,a.Uk)("参考："),$={href:"http://xueliang.org/article/detail/20180223141445088",target:"_blank",rel:"noopener noreferrer"},A=(0,a.Uk)("xueliang.org"),_=(0,a.uE)('<p>想暂存一个文件的部分内容，而不是文件的全部内容。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> <span class="token function">add</span> -p <span class="token operator">&lt;</span>filename<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>加上 <code>-p</code> 或 <code>--patch</code> 会打开交互模式，它会将文件分解成它认为合理的 <em>块（hunk）</em> （文件的一部分）。能够用 <code>s</code> 选项来分隔提交（commit）。其他选项说明：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>y 暂存该块\nn 不暂存该块\na 暂存该块及该文件中的剩余所有块\nd 不暂存该块及该文件中的剩余所有块\ng 选择并跳转至指定块块\n/ 搜索与给定的正则表达式匹配的块\nj 离开当前未定的块，处理下一个未定的块\nJ 离开当前未定的块，处理下一个块\nk 离开当前未定的块，处理上一个未定的块\nK 离开当前未定的块，处理上一个块\ns 将当前的大块分成更小的块\ne 手动编辑当前的块\n? 打印帮助\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>然而，如果这个文件是新的，会没有这个选择，则可以先执行 <code>git add -N &lt;filename&gt;</code>。之后你可以继续 <code>git add -p &lt;filename&gt;</code>。</p><h3 id="撤销暂存的内容-恢复到工作区" tabindex="-1"><a class="header-anchor" href="#撤销暂存的内容-恢复到工作区" aria-hidden="true">#</a> 撤销暂存的内容，恢复到工作区</h3><p>某些文件被 add 到了暂存区，现在需要撤销这个文件的 add 操作，并保留这个文件的修改内容。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> reset --mixed <span class="token punctuation">[</span>filename<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>如果是需要撤销所有的 add，可使用 <code>git reset --mixed</code> 或 <code>git reset HEAD .</code> 实现。</p><h2 id="未暂存-unstaged-的内容" tabindex="-1"><a class="header-anchor" href="#未暂存-unstaged-的内容" aria-hidden="true">#</a> 未暂存(Unstaged)的内容</h2><h3 id="把未暂存的内容移动到一个新分支" tabindex="-1"><a class="header-anchor" href="#把未暂存的内容移动到一个新分支" aria-hidden="true">#</a> 把未暂存的内容移动到一个新分支</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> checkout -b <span class="token operator">&lt;</span>new branch<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="把未暂存的内容移动到另一个已存在的分支" tabindex="-1"><a class="header-anchor" href="#把未暂存的内容移动到另一个已存在的分支" aria-hidden="true">#</a> 把未暂存的内容移动到另一个已存在的分支</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> stash\n$ <span class="token function">git</span> checkout <span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span>\n$ <span class="token function">git</span> stash pop\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="丢弃本地未提交的变化-uncommitted-changes" tabindex="-1"><a class="header-anchor" href="#丢弃本地未提交的变化-uncommitted-changes" aria-hidden="true">#</a> 丢弃本地未提交的变化(uncommitted changes)</h3><p>如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># one commit</span>\n<span class="token punctuation">(</span>my-branch<span class="token punctuation">)</span>$ <span class="token function">git</span> reset --hard HEAD^\n<span class="token comment"># two commits</span>\n<span class="token punctuation">(</span>my-branch<span class="token punctuation">)</span>$ <span class="token function">git</span> reset --hard HEAD^^\n<span class="token comment"># four commits</span>\n<span class="token punctuation">(</span>my-branch<span class="token punctuation">)</span>$ <span class="token function">git</span> reset --hard HEAD~4\n<span class="token comment"># or</span>\n<span class="token punctuation">(</span>main<span class="token punctuation">)</span>$ <span class="token function">git</span> checkout -f\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>重置某个特殊的文件, 你可以用文件名做为参数:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> reset filename\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="丢弃某些未暂存的内容" tabindex="-1"><a class="header-anchor" href="#丢弃某些未暂存的内容" aria-hidden="true">#</a> 丢弃某些未暂存的内容</h3><p>如果你想丢弃工作目录中的一部分内容，而不是全部。</p><p>签出（checkout）不需要的内容，保留需要的。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> checkout -p\n<span class="token comment"># Answer y to all of the snippets you want to drop</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>另外一个方法是使用 <code>stash</code>，Stash 所有要保留下的内容，重置工作拷贝，重新应用保留的部分。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> stash -p\n<span class="token comment"># Select all of the snippets you want to save</span>\n$ <span class="token function">git</span> reset --hard\n$ <span class="token function">git</span> stash pop\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>或者，stash 你不需要的部分，然后 stash drop。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> stash -p\n<span class="token comment"># Select all of the snippets you don&#39;t want to save</span>\n$ <span class="token function">git</span> stash drop\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="分支-branches" tabindex="-1"><a class="header-anchor" href="#分支-branches" aria-hidden="true">#</a> 分支(Branches)</h2><h3 id="我从错误的分支拉取了内容-或把内容拉取到了错误的分支" tabindex="-1"><a class="header-anchor" href="#我从错误的分支拉取了内容-或把内容拉取到了错误的分支" aria-hidden="true">#</a> 我从错误的分支拉取了内容，或把内容拉取到了错误的分支</h3><p>这是另外一种使用 <code>git reflog</code> 情况，找到在这次错误拉（pull）之前 HEAD 的指向。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">(</span>main<span class="token punctuation">)</span>$ <span class="token function">git</span> reflog\nab7555f HEAD@<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span>: pull origin wrong-branch: Fast-forward\nc5bc55a HEAD@<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span>: checkout: checkout message goes here\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>重置分支到你所需的提交（desired commit）：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> reset --hard c5bc55a\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>完成。</p><h2 id="变基-rebase-和合并-merge" tabindex="-1"><a class="header-anchor" href="#变基-rebase-和合并-merge" aria-hidden="true">#</a> 变基(rebase)和合并(merge)</h2><h3 id="我想撤销rebase-merge" tabindex="-1"><a class="header-anchor" href="#我想撤销rebase-merge" aria-hidden="true">#</a> 我想撤销rebase/merge</h3><p>你可以合并（merge）或变基（rebase）了一个错误的分支，或者完成不了一个进行中的 rebase/merge。 Git 在进行危险操作的时候会把原始的HEAD保存在一个叫 <code>ORIG_HEAD</code> 的变量里，所以要把分支恢复到 rebase/merge 前的状态是很容易的。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">(</span>my-branch<span class="token punctuation">)</span>$ <span class="token function">git</span> reset --hard ORIG_HEAD\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="我已经rebase过-但是我不想强推-force-push" tabindex="-1"><a class="header-anchor" href="#我已经rebase过-但是我不想强推-force-push" aria-hidden="true">#</a> 我已经rebase过, 但是我不想强推(force push)</h3><p>不幸的是，如果你想把这些变化（changes）反应到远程分支上，你就必须得强推（force push）。 是因你快进（Fast forward）了提交，改变了 Git 历史，远程分支不会接受变化（changes），除非强推（force push）。</p><p>这就是许多人使用 merge 工作流，而不是 rebasing 工作流的主要原因之一，开发者的强推（force push）会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化（changes）反映到远程分支上，而是按下面的做：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">(</span>main<span class="token punctuation">)</span>$ <span class="token function">git</span> checkout my-branch\n<span class="token punctuation">(</span>my-branch<span class="token punctuation">)</span>$ <span class="token function">git</span> rebase -i main\n<span class="token punctuation">(</span>my-branch<span class="token punctuation">)</span>$ <span class="token function">git</span> checkout main\n<span class="token punctuation">(</span>main<span class="token punctuation">)</span>$ <span class="token function">git</span> merge --ff-only my-branch\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div>',42),w=(0,a.Uk)("更多, 参见 "),y={href:"http://stackoverflow.com/questions/11058312/how-can-i-use-git-rebase-without-requiring-a-forced-push",target:"_blank",rel:"noopener noreferrer"},q=(0,a.Uk)("this SO thread"),B=(0,a.Uk)("."),D=(0,a.uE)('<h3 id="检查是否分支上的所有提交-commit-都合并-merge-过了" tabindex="-1"><a class="header-anchor" href="#检查是否分支上的所有提交-commit-都合并-merge-过了" aria-hidden="true">#</a> 检查是否分支上的所有提交(commit)都合并(merge)过了</h3><p>检查一个分支上的所有提交（commit）是否都已经合并（merge）到了其它分支，你应该在这些分支的 head (或任何 commits)之间做一次 diff：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">(</span>main<span class="token punctuation">)</span>$ <span class="token function">git</span> log --graph --left-right --cherry-pick --oneline HEAD<span class="token punctuation">..</span>.feature/120-on-scroll\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这会告诉你在一个分支里有而另一个分支没有的所有提交（commit），和分支之间不共享的提交（commit）的列表。 另一个做法可以是：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">(</span>main<span class="token punctuation">)</span>$ <span class="token function">git</span> log main ^feature/120-on-scroll --no-merges\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="交互式rebase-interactive-rebase-可能出现的问题" tabindex="-1"><a class="header-anchor" href="#交互式rebase-interactive-rebase-可能出现的问题" aria-hidden="true">#</a> 交互式rebase(interactive rebase)可能出现的问题</h3><h4 id="这个rebase编辑屏幕出现-noop" tabindex="-1"><a class="header-anchor" href="#这个rebase编辑屏幕出现-noop" aria-hidden="true">#</a> 这个rebase编辑屏幕出现&#39;noop&#39;</h4><p>如果你看到的是这样：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>noop\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这意味着你 rebase 的分支和当前分支在同一个提交(commit)上, 或者 <em>领先(ahead)</em> 当前分支。 你可以尝试：</p><ul><li>检查确保主(main)分支没有问题</li><li>rebase <code>HEAD~2</code> 或者更早</li></ul><h4 id="有冲突的情况" tabindex="-1"><a class="header-anchor" href="#有冲突的情况" aria-hidden="true">#</a> 有冲突的情况</h4><p>如果你不能成功的完成 rebase，你可能必须要解决冲突。</p><p>首先执行 <code>git status</code> 找出哪些文件有冲突：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">(</span>my-branch<span class="token punctuation">)</span>$ <span class="token function">git</span> status\nOn branch my-branch\nChanges not staged <span class="token keyword">for</span> commit:\n  <span class="token punctuation">(</span>use <span class="token string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed<span class="token punctuation">)</span>\n  <span class="token punctuation">(</span>use <span class="token string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>\n\n\tmodified:   README.md\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在这个例子里面，<code>README.md</code> 有冲突。 打开这个文件找到类似下面的内容:</p><div class="language-markdown ext-md line-numbers-mode"><pre class="language-markdown"><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n<span class="token title important">some code\n<span class="token punctuation">=========</span></span>\nsome code\n<span class="token blockquote punctuation">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span> new-commit\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>你需要解决新提交的代码（示例里, 从中间 <code>==</code> 线到 <code>new-commit</code> 的地方）与 <code>HEAD</code> 之间不一样的地方。</p><p>有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor)：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">(</span>main*<span class="token punctuation">)</span>$ <span class="token function">git</span> mergetool -t opendiff\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>在你解决完所有冲突和测试过后，<code>git add</code> 变化了的(changed)文件，然后用 <code>git rebase --continue</code> 继续 rebase。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">(</span>my-branch<span class="token punctuation">)</span>$ <span class="token function">git</span> <span class="token function">add</span> README.md\n<span class="token punctuation">(</span>my-branch<span class="token punctuation">)</span>$ <span class="token function">git</span> rebase --continue\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果在解决完所有的冲突过后，得到了与提交前一样的结果，可以执行 <code>git rebase --skip</code>。</p><p>任何时候你想结束整个 rebase 过程，回来 rebase 前的分支状态，你可以做：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">(</span>my-branch<span class="token punctuation">)</span>$ <span class="token function">git</span> rebase --abort\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="stash" tabindex="-1"><a class="header-anchor" href="#stash" aria-hidden="true">#</a> Stash</h2><p><code>git stash</code> 会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。</p><h3 id="暂存所有改动" tabindex="-1"><a class="header-anchor" href="#暂存所有改动" aria-hidden="true">#</a> 暂存所有改动</h3><p>暂存你工作目录下的所有改动</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> stash\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>你可以使用 <code>-u</code> 来排除一些文件</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> stash -u\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="暂存指定文件" tabindex="-1"><a class="header-anchor" href="#暂存指定文件" aria-hidden="true">#</a> 暂存指定文件</h3><p>假设你只想暂存某一个文件</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> stash push working-directory-path/filename.ext\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>假设你想暂存多个文件</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> stash push working-directory-path/filename1.ext working-directory-path/filename2.ext\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="杂项" tabindex="-1"><a class="header-anchor" href="#杂项" aria-hidden="true">#</a> 杂项</h2><h3 id="克隆所有子模块" tabindex="-1"><a class="header-anchor" href="#克隆所有子模块" aria-hidden="true">#</a> 克隆所有子模块</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">git</span> clone --recursive git://github.com/foo/bar.git\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>如果已经克隆了:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ git submodule update --init --recursive\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="恢复已删除标签-tag" tabindex="-1"><a class="header-anchor" href="#恢复已删除标签-tag" aria-hidden="true">#</a> 恢复已删除标签(tag)</h3><p>如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ git fsck --unreachable | grep tag\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div>',45),U=(0,a.Uk)("记下这个标签(tag)的hash，然后用Git的 "),H={href:"http://git-scm.com/docs/git-update-ref",target:"_blank",rel:"noopener noreferrer"},G=(0,a.Uk)("update-ref"),F=(0,a.Uk)(":"),R=(0,a.uE)('<div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ git update-ref refs/tags/&lt;tag_name&gt; &lt;hash&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这时你的标签(tag)应该已经恢复了。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',3),C={href:"https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md",target:"_blank",rel:"noopener noreferrer"},S=(0,a.Uk)("git-flight-rules"),O=(0,a.Uk)(" - GitHub"),W={},N=(0,s(3744).Z)(W,[["render",function(e,n){const s=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[t,(0,a._)("p",null,[i,(0,a._)("a",l,[c,(0,a.Wm)(s)]),r]),p,(0,a._)("p",null,[(0,a._)("a",o,[d,(0,a.Wm)(s)])]),u,(0,a._)("div",m,[h,(0,a._)("p",null,[b,(0,a._)("a",g,[v,(0,a.Wm)(s)]),k,f])]),x,(0,a._)("blockquote",null,[(0,a._)("p",null,[E,(0,a._)("a",$,[A,(0,a.Wm)(s)])])]),_,(0,a._)("p",null,[w,(0,a._)("a",y,[q,(0,a.Wm)(s)]),B]),D,(0,a._)("p",null,[U,(0,a._)("a",H,[G,(0,a.Wm)(s)]),F]),R,(0,a._)("ul",null,[(0,a._)("li",null,[(0,a._)("a",C,[S,(0,a.Wm)(s)]),O])])],64)}]])},3744:(e,n)=>{n.Z=(e,n)=>{for(const[s,a]of n)e[s]=a;return e}}}]);