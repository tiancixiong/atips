"use strict";(self.webpackChunkatips=self.webpackChunkatips||[]).push([[4772],{9194:(t,e,n)=>{n.r(e),n.d(e,{data:()=>r});const r={key:"v-416d71ea",path:"/java/concurrent/java-concurrent-locks-AQS.html",title:"JUC锁 - 锁核心类AQS",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"java/concurrent/java-concurrent-locks-AQS.md",git:{updatedTime:1635671824e3,contributors:[{name:"TianCi.Xiong",email:"tiancixiong@163.com",commits:1}]}}},1630:(t,e,n)=>{n.r(e),n.d(e,{default:()=>o});const r=(0,n(6252).uE)('<h1 id="juc锁-锁核心类aqs" tabindex="-1"><a class="header-anchor" href="#juc锁-锁核心类aqs" aria-hidden="true">#</a> JUC锁 - 锁核心类AQS</h1><p><strong>AQS</strong>(AbstractQueuedSynchronizer)：抽象类，是 Java 并发锁的核心。它提供了一个基于<em>FIFO</em>(先进先出)队列，可以用于构建锁或者其他相关同步装置的基础框架。</p><p>并发编程有两个核心问题：互斥和同步。</p><ul><li><p><strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；</p></li><li><p><strong>同步</strong>，即线程之间如何通信、协作。</p></li></ul><p>这两大问题，管程（<code>sychronized</code>）都是能够解决的。<strong>J.U.C 包还提供了 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题</strong>。</p>',5),a={},o=(0,n(3744).Z)(a,[["render",function(t,e){return r}]])},3744:(t,e)=>{e.Z=(t,e)=>{for(const[n,r]of e)t[n]=r;return t}}}]);