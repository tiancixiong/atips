"use strict";(self.webpackChunkatips=self.webpackChunkatips||[]).push([[4457],{5948:(t,e,a)=>{a.r(e),a.d(e,{data:()=>n});const n={key:"v-74437107",path:"/java/basic/java-basic-grammar.html",title:"Java 基础 - 基础语法",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"数据类型",slug:"数据类型",children:[{level:3,title:"八种基本类型",slug:"八种基本类型",children:[]},{level:3,title:"包装类型",slug:"包装类型",children:[]},{level:3,title:"Integer的缓存机制",slug:"integer的缓存机制",children:[]},{level:3,title:"参考文献",slug:"参考文献",children:[]}]},{level:2,title:"String",slug:"string",children:[{level:3,title:"概览",slug:"概览",children:[]},{level:3,title:'String对"+"的重载',slug:"string对-的重载",children:[]},{level:3,title:"参考文献",slug:"参考文献-1",children:[]}]},{level:2,title:"运算符",slug:"运算符",children:[{level:3,title:"算术运算符",slug:"算术运算符",children:[]},{level:3,title:"关系运算符",slug:"关系运算符",children:[]},{level:3,title:"位运算符",slug:"位运算符",children:[]},{level:3,title:"逻辑运算符",slug:"逻辑运算符",children:[]},{level:3,title:"赋值运算符",slug:"赋值运算符",children:[]},{level:3,title:"条件运算符（?:）",slug:"条件运算符",children:[]},{level:3,title:"instanceof 运算符",slug:"instanceof-运算符",children:[]},{level:3,title:"Java运算符优先级",slug:"java运算符优先级",children:[]}]},{level:2,title:"包命名规则",slug:"包命名规则",children:[]},{level:2,title:"关键字",slug:"关键字",children:[{level:3,title:"Java中常见的关键字",slug:"java中常见的关键字",children:[]},{level:3,title:"访问权限修饰符",slug:"访问权限修饰符",children:[]},{level:3,title:"final",slug:"final",children:[]},{level:3,title:"static",slug:"static",children:[]},{level:3,title:"this",slug:"this",children:[]},{level:3,title:"super",slug:"super",children:[]}]},{level:2,title:"反射",slug:"反射",children:[]},{level:2,title:"异常",slug:"异常",children:[]},{level:2,title:"泛型",slug:"泛型",children:[{level:3,title:"常用的通配符",slug:"常用的通配符",children:[]}]},{level:2,title:"枚举",slug:"枚举",children:[]}],filePathRelative:"java/basic/java-basic-grammar.md",git:{updatedTime:1719836412e3,contributors:[{name:"TianCi.Xiong",email:"tiancixiong@163.com",commits:3},{name:"Tianci.Xiong",email:"tiancixiong@163.com",commits:2}]}}},4588:(t,e,a)=>{a.r(e),a.d(e,{default:()=>D});var n=a(6252);const s=(0,n.uE)('<h1 id="java-基础-基础语法" tabindex="-1"><a class="header-anchor" href="#java-基础-基础语法" aria-hidden="true">#</a> Java 基础 - 基础语法</h1><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h2><h3 id="八种基本类型" tabindex="-1"><a class="header-anchor" href="#八种基本类型" aria-hidden="true">#</a> 八种基本类型</h3><p>Java 语言提供了<strong>八种</strong>基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><table><thead><tr><th>数据类型</th><th>所占字节</th><th>默认值</th><th>可表示的范围</th></tr></thead><tbody><tr><td>byte</td><td>1字节(8bit)</td><td>0</td><td>-128(-2^7^) ~ 127 (2^7^-1)</td></tr><tr><td>short</td><td>2字节(16bit)</td><td>0</td><td>-32768(-2^15^) ~ 32767(-2^15^-1)</td></tr><tr><td>int</td><td>4字节(32bit)</td><td>0</td><td>-2^31^ ~ 2^31^-1</td></tr><tr><td>long</td><td>8字节(64bit)</td><td>0L</td><td>-2^63^ ~ 2^63^-1</td></tr><tr><td>float</td><td>4字节(32bit)</td><td>0.0f</td><td>-2^128^ ~ 2^128^-1</td></tr><tr><td>double</td><td>8字节(64bit)</td><td>0.0d</td><td>-2^1024^ ~ 2^1024^-1</td></tr><tr><td>boolean</td><td>1位</td><td>false</td><td>true/false</td></tr><tr><td>char</td><td>2字节(16bit)</td><td>‘\\u000’</td><td>&#39;\\u0000&#39;(即为0) ~ &#39;\\uffff &#39;(即为65,535)</td></tr></tbody></table><h3 id="包装类型" tabindex="-1"><a class="header-anchor" href="#包装类型" aria-hidden="true">#</a> 包装类型</h3><p>基本类型都有对应的包装类型，具有对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment">//自动装箱</span>\n<span class="token keyword">int</span> i2 <span class="token operator">=</span> i1<span class="token punctuation">;</span>        <span class="token comment">//自动拆箱</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="integer的缓存机制" tabindex="-1"><a class="header-anchor" href="#integer的缓存机制" aria-hidden="true">#</a> Integer的缓存机制</h3>',10),l=(0,n.Uk)("详情："),d={href:"http://www.hollischuang.com/?p=1174",target:"_blank",rel:"noopener noreferrer"},r=(0,n.Uk)("Java中整型的缓存机制"),i=(0,n.Uk)("、"),o={href:"http://javapapers.com/java/java-integer-cache/",target:"_blank",rel:"noopener noreferrer"},c=(0,n.Uk)("Java Integer Cache"),p=(0,n.Uk)(" - 英文"),u=(0,n.uE)('<p>在 Java 5 中，在 Integer 的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p><blockquote><p>适用于整数值区间 -128 至 +127。</p><p>只适用于自动装箱。使用构造函数创建对象不适用。</p></blockquote><p>Java 的编译器把基本数据类型自动转换成封装类对象的过程叫做 <code>自动装箱</code>，相当于使用 <code>valueOf</code> 方法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//this is autoboxing</span>\n<span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//under the hood</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>现在我们知道了这种机制在源码中哪里使用了，那么接下来我们就看看JDK中的 <code>valueOf</code> 方法。下面是 <code>JDK 1.8.0 build 25</code> 的实现：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// java.lang.Integer</span>\n<span class="token doc-comment comment">/**\n * Returns an <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token class-name">Integer</span></span></span><span class="token punctuation">}</span> instance representing the specified\n * <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token keyword">int</span></span></span><span class="token punctuation">}</span> value.  If a new <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token class-name">Integer</span></span></span><span class="token punctuation">}</span> instance is not\n * required, this method should generally be used in preference to\n * the constructor <span class="token punctuation">{</span><span class="token keyword">@link</span> <span class="token reference"><span class="token punctuation">#</span><span class="token function">Integer</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span></span><span class="token punctuation">}</span>, as this method is likely\n * to yield significantly better space and time performance by\n * caching frequently requested values.\n *\n * This method will always cache values in the range -128 to 127,\n * inclusive, and may cache other values outside of this range.\n *\n * <span class="token keyword">@param</span>  <span class="token parameter">i</span> an <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token keyword">int</span></span></span><span class="token punctuation">}</span> value.\n * <span class="token keyword">@return</span> an <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java"><span class="token class-name">Integer</span></span></span><span class="token punctuation">}</span> instance representing <span class="token punctuation">{</span><span class="token keyword">@code</span> <span class="token code-section"><span class="token code language-java">i</span></span><span class="token punctuation">}</span>.\n * <span class="token keyword">@since</span>  1.5\n */</span>\n<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>\n\t\t<span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\t<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>在创建对象之前先从 IntegerCache.cache 中寻找。如果没找到才使用 new 新建对象。</p><h4 id="其他缓存的对象" tabindex="-1"><a class="header-anchor" href="#其他缓存的对象" aria-hidden="true">#</a> 其他缓存的对象</h4><p>这种缓存行为不仅适用于 Integer 对象。我们针对所有的整数类型的类都有类似的缓存机制。</p><ul><li><strong>ByteCache</strong> 用于缓存 Byte 对象</li><li><strong>ShortCache</strong> 用于缓存 Short 对象</li><li><strong>LongCache</strong> 用于缓存 Long 对象</li><li><strong>CharacterCache</strong> 用于缓存 Character 对象</li></ul><p><code>Byte</code>、 <code>Short</code>、<code>Long</code> 有固定范围:：-128 到 127。对于 <code>Character</code>，范围是 0 到 127。除了 <code>Integer</code> 以外，这个范围都不能改变。</p><h3 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h3>',12),h={href:"https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/basic/2%E3%80%81Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md",target:"_blank",rel:"noopener noreferrer"},g=(0,n.Uk)("Java基本数据类型"),f=(0,n.Uk)(" - GitHub@h2pl"),b={href:"https://hollischuang.github.io/toBeTopJavaer/#/basics/java-basic/boxing-unboxing",target:"_blank",rel:"noopener noreferrer"},k=(0,n.Uk)("自动拆装箱"),y=(0,n.Uk)(" - GitHub@hollischuang"),x=(0,n.uE)('<h2 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h2><h3 id="概览" tabindex="-1"><a class="header-anchor" href="#概览" aria-hidden="true">#</a> 概览</h3><p>String 被声明为 <code>final</code>，因此它不可被<em>继承</em>。</p><p>内部使用 <strong>char 数组</strong>存储数据，<u>该数组被声明为 final</u>，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// java.lang.String</span>\n<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>\n    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>\n    <span class="token doc-comment comment">/** The value is used for character storage. */</span>\n    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="string对-的重载" tabindex="-1"><a class="header-anchor" href="#string对-的重载" aria-hidden="true">#</a> String对&quot;+&quot;的重载</h3><p>Java 中，想要拼接字符串，最简单的方式就是通过 <code>+</code> 连接两个字符串。</p><p>有人把 Java 中使用 <code>+</code> 拼接字符串的功能理解为运算符重载。其实并不是，Java 是不支持运算符重载的。这其实只是 Java 提供的一个语法糖。</p><blockquote><p>运算符重载：在计算机程序设计中，运算符重载（英语：operator overloading）是多态的一种。运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。</p></blockquote><blockquote><p>语法糖：语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。</p></blockquote><p>前面提到过，使用 <code>+</code> 拼接字符串，其实只是 Java 提供的一个语法糖。Java 字符串常量在使用 <code>+</code> 对字符串的拼接过程中，是将 String 转成了 <strong>StringBuilder</strong> 后，使用其 <strong>append</strong> 方法进行处理的。</p><p>但是，String 的使用 <code>+</code> 字符串拼接也不全都是基于 <code>StringBuilder.append</code>，还有种特殊情况，那就是如果是两个固定的字面量拼接，如：</p><div class="language-markup ext-markup line-numbers-mode"><pre class="language-markup"><code>String s = &quot;a&quot; + &quot;b&quot;;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>编译器会进行常量折叠(因为两个都是编译期常量，编译期可知)，直接变成 <code>String s = &quot;ab&quot;</code>。</p><h3 id="参考文献-1" tabindex="-1"><a class="header-anchor" href="#参考文献-1" aria-hidden="true">#</a> 参考文献</h3>',15),m={href:"https://hollischuang.github.io/toBeTopJavaer/#/basics/java-basic/final-string",target:"_blank",rel:"noopener noreferrer"},v=(0,n.Uk)("String"),w=(0,n.Uk)(" - GitHub@hollischuang"),j=(0,n.uE)('<h2 id="运算符" tabindex="-1"><a class="header-anchor" href="#运算符" aria-hidden="true">#</a> 运算符</h2><h3 id="算术运算符" tabindex="-1"><a class="header-anchor" href="#算术运算符" aria-hidden="true">#</a> 算术运算符</h3><p>表格中的实例假设整数变量 A=10、B=20：</p><table><thead><tr><th style="text-align:left;">操作符</th><th style="text-align:left;">描述</th><th style="text-align:left;">例子</th></tr></thead><tbody><tr><td style="text-align:left;">+</td><td style="text-align:left;">加法，相加运算符两侧的值</td><td style="text-align:left;">A + B 等于 30</td></tr><tr><td style="text-align:left;">-</td><td style="text-align:left;">减法，左操作数减去右操作数</td><td style="text-align:left;">A – B 等于 -10</td></tr><tr><td style="text-align:left;">*</td><td style="text-align:left;">乘法，相乘操作符两侧的值</td><td style="text-align:left;">A * B等于200</td></tr><tr><td style="text-align:left;">/</td><td style="text-align:left;">除法，左操作数除以右操作数</td><td style="text-align:left;">B / A等于2</td></tr><tr><td style="text-align:left;">％</td><td style="text-align:left;">取余，左操作数除以右操作数的余数</td><td style="text-align:left;">B%A等于0</td></tr><tr><td style="text-align:left;">++</td><td style="text-align:left;">自增，操作数的值增加1</td><td style="text-align:left;">B++ 或 ++B 等于 21</td></tr><tr><td style="text-align:left;">--</td><td style="text-align:left;">自减，操作数的值减少1</td><td style="text-align:left;">B-- 或 --B 等于 19</td></tr></tbody></table><h3 id="关系运算符" tabindex="-1"><a class="header-anchor" href="#关系运算符" aria-hidden="true">#</a> 关系运算符</h3><p>表格中的实例假设整数变量 A=10、B=20：</p><table><thead><tr><th style="text-align:left;">运算符</th><th style="text-align:left;">描述</th><th style="text-align:left;">例子</th></tr></thead><tbody><tr><td style="text-align:left;">==</td><td style="text-align:left;">检查如果两个操作数的值是否相等，如果相等则条件为真</td><td style="text-align:left;">A==B 为假</td></tr><tr><td style="text-align:left;">!=</td><td style="text-align:left;">检查如果两个操作数的值是否相等，如果值不相等则条件为真</td><td style="text-align:left;">A!=B 为真</td></tr><tr><td style="text-align:left;">&gt;</td><td style="text-align:left;">检查左操作数的值是否大于右操作数的值，如果是那么条件为真</td><td style="text-align:left;">A&gt;B 为假</td></tr><tr><td style="text-align:left;">&lt;</td><td style="text-align:left;">检查左操作数的值是否小于右操作数的值，如果是那么条件为真</td><td style="text-align:left;">A&lt;B 为真</td></tr><tr><td style="text-align:left;">&gt;=</td><td style="text-align:left;">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真</td><td style="text-align:left;">A&gt;=B 为假</td></tr><tr><td style="text-align:left;">&lt;=</td><td style="text-align:left;">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真</td><td style="text-align:left;">A&lt;=B 为真</td></tr></tbody></table><h3 id="位运算符" tabindex="-1"><a class="header-anchor" href="#位运算符" aria-hidden="true">#</a> 位运算符</h3><p>Java 定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。</p><p>位运算符作用在所有的<strong>位</strong>上，并且<u>按位运算</u>。假设 a = 60、b = 13；它们的二进制格式表示将如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>A = 0011 1100\nB = 0000 1101\n-----------------\nA&amp;B = 0000 1100\nA | B = 0011 1101\nA ^ B = 0011 0001\n~A= 1100 0011\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：</p><table><thead><tr><th style="text-align:left;">操作符</th><th style="text-align:left;">描述</th><th style="text-align:left;">例子</th></tr></thead><tbody><tr><td style="text-align:left;">＆</td><td style="text-align:left;">按位与。如果相对应位都是1，则结果为1；否则为0</td><td style="text-align:left;">（A＆B），得到12，即<code>0000 1100</code></td></tr><tr><td style="text-align:left;">|</td><td style="text-align:left;">按位或。如果相对应位都是 0，则结果为 0；否则为 1</td><td style="text-align:left;">（A | B）得到61，即 <code>0011 1101</code></td></tr><tr><td style="text-align:left;">^</td><td style="text-align:left;">按位异或。如果相对应位值相同，则结果为0；否则为1</td><td style="text-align:left;">（A ^ B）得到49，即 <code>0011 0001</code></td></tr><tr><td style="text-align:left;">〜</td><td style="text-align:left;">按位取反。翻转操作数的每一位，即0变成1，1变成0。</td><td style="text-align:left;">（〜A）得到 -61，即<code>1100 0011</code></td></tr><tr><td style="text-align:left;">&lt;&lt;</td><td style="text-align:left;">按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td style="text-align:left;">A &lt;&lt; 2 得到 240，即 <code>1111 0000</code></td></tr><tr><td style="text-align:left;">&gt;&gt;</td><td style="text-align:left;">按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td style="text-align:left;">A &gt;&gt; 2 得到15即 <code>1111</code></td></tr><tr><td style="text-align:left;">&gt;&gt;&gt;</td><td style="text-align:left;">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td style="text-align:left;">A&gt;&gt;&gt;2 得到15即 <code>0000 1111</code></td></tr></tbody></table><h3 id="逻辑运算符" tabindex="-1"><a class="header-anchor" href="#逻辑运算符" aria-hidden="true">#</a> 逻辑运算符</h3><p>下表列出了逻辑运算符的基本运算，假设布尔变量A为真(true)，变量B为假(false)：</p><table><thead><tr><th style="text-align:left;">操作符</th><th style="text-align:left;">描述</th><th style="text-align:left;">例子</th></tr></thead><tbody><tr><td style="text-align:left;">&amp;&amp;</td><td style="text-align:left;"><strong>逻辑与</strong>运算符。当且仅当两个操作数都为真，条件才为真。</td><td style="text-align:left;">(A &amp;&amp; B) 为假</td></tr><tr><td style="text-align:left;">||</td><td style="text-align:left;"><strong>逻辑或</strong>操作符。如果任何两个操作数任何一个为真，条件为真。</td><td style="text-align:left;">(A || B) 为真</td></tr><tr><td style="text-align:left;">!</td><td style="text-align:left;"><strong>逻辑非</strong>运算符。用来反转操作数的逻辑状态。如果条件为 true，则逻辑非运算符将得到 false。</td><td style="text-align:left;">!(A &amp;&amp; B) 为真</td></tr></tbody></table><h4 id="短路逻辑运算符" tabindex="-1"><a class="header-anchor" href="#短路逻辑运算符" aria-hidden="true">#</a> 短路逻辑运算符</h4><p>所谓短路逻辑运算符就是逻辑操作符执行短路求值。**短路(short-circuiting)**运算：若左边的式子可以决定逻辑表达式的结果，右边的式子不执行。在 Java 中有两种短路运算符：</p><ul><li><strong>&amp;&amp;</strong>：短路与；如果左边的表达式值为 <em>false</em>，那么就不会再执行右边的表达式了；</li><li><strong>||</strong>：短路或；如果左边的表达式值为 <em>true</em>，那么就不会再执行右边的表达式了。</li></ul><p>比如下方例子1中，因为 <code>10&gt;20</code> 结果为 false，就可以推断出 <code>10&gt;20 &amp;&amp; 10/0</code> 结果为 false，所以 <em>&amp;&amp;</em> 右侧的 <code>10/0</code> 不会被执行到，即被短路了，程序并不会因为除零而报错；同样的例子2中，由于 <code>10&lt;20</code> 为 true，导致 <code>10/0</code> 被短路了。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">&gt;</span> <span class="token number">20</span> <span class="token operator">&amp;&amp;</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">0</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>\n<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">&lt;</span> <span class="token number">20</span> <span class="token operator">||</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">0</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="赋值运算符" tabindex="-1"><a class="header-anchor" href="#赋值运算符" aria-hidden="true">#</a> 赋值运算符</h3><table><thead><tr><th style="text-align:left;">操作符</th><th style="text-align:left;">描述</th><th style="text-align:left;">例子</th></tr></thead><tbody><tr><td style="text-align:left;">=</td><td style="text-align:left;">简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td style="text-align:left;"><code>C=A+B</code> 将把 A+B 得到的值赋给 C</td></tr><tr><td style="text-align:left;">+=</td><td style="text-align:left;">加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td style="text-align:left;"><code>C+=A</code> 等价于 C=C+A</td></tr><tr><td style="text-align:left;">-=</td><td style="text-align:left;">减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td style="text-align:left;"><code>C-=A</code> 等价于 <code>C=C-A</code></td></tr><tr><td style="text-align:left;">*=</td><td style="text-align:left;">乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td style="text-align:left;"><code>C*=A</code> 等价于 <code>C=C*A</code></td></tr><tr><td style="text-align:left;">/=</td><td style="text-align:left;">除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td style="text-align:left;"><code>C/=A</code>，C 与 A 同类型时等价于 <code>C=C/A</code></td></tr><tr><td style="text-align:left;">％=</td><td style="text-align:left;">取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td style="text-align:left;"><code>C％=A</code> 等价于 <code>C=C％A</code></td></tr><tr><td style="text-align:left;">&lt;&lt;=</td><td style="text-align:left;">左移位赋值运算符</td><td style="text-align:left;"><code>C&lt;&lt;=2</code> 等价于 <code>C=C&lt;&lt; 2</code></td></tr><tr><td style="text-align:left;">&gt;&gt;=</td><td style="text-align:left;">右移位赋值运算符</td><td style="text-align:left;"><code>C &gt;&gt;=2</code> 等价于 <code>C=C &gt;&gt; 2</code></td></tr><tr><td style="text-align:left;">＆=</td><td style="text-align:left;">按位与赋值运算符</td><td style="text-align:left;"><code>C＆=2</code> 等价于 <code>C=C＆2</code></td></tr><tr><td style="text-align:left;">^=</td><td style="text-align:left;">按位异或赋值操作符</td><td style="text-align:left;"><code>C^=2</code> 等价于 <code>C=C^2</code></td></tr><tr><td style="text-align:left;">|=</td><td style="text-align:left;">按位或赋值操作符</td><td style="text-align:left;">`C</td></tr></tbody></table><h3 id="条件运算符" tabindex="-1"><a class="header-anchor" href="#条件运算符" aria-hidden="true">#</a> 条件运算符（?:）</h3><p>条件运算符 <code>?:</code> 也被称为<strong>三元运算符</strong>。该运算符有 3 个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>variable x <span class="token operator">=</span> <span class="token punctuation">(</span>expression<span class="token punctuation">)</span> <span class="token operator">?</span> value1 <span class="token operator">:</span> value2<span class="token punctuation">;</span>\n<span class="token comment">// expression==true，则 x=value1；expression==false，则 x=value2</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="instanceof-运算符" tabindex="-1"><a class="header-anchor" href="#instanceof-运算符" aria-hidden="true">#</a> instanceof 运算符</h3><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型），返回布尔值。</p><p>instanceof 运算符使用格式如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">(</span> <span class="token class-name">Object</span> reference variable <span class="token punctuation">)</span> <span class="token keyword">instanceof</span>  <span class="token punctuation">(</span><span class="token keyword">class</span><span class="token operator">/</span><span class="token keyword">interface</span> type<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="java运算符优先级" tabindex="-1"><a class="header-anchor" href="#java运算符优先级" aria-hidden="true">#</a> Java运算符优先级</h3><p>当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。</p><p>下表中具有最高优先级的运算符在的表的最上面（即后缀里面的内容最先进行运算），最低优先级的在表的底部。</p><table><thead><tr><th style="text-align:left;">类别</th><th style="text-align:left;">操作符</th><th style="text-align:left;">关联性</th></tr></thead><tbody><tr><td style="text-align:left;">后缀</td><td style="text-align:left;">()、[]、. (点操作符)</td><td style="text-align:left;">左到右</td></tr><tr><td style="text-align:left;">一元</td><td style="text-align:left;">expr++、expr--</td><td style="text-align:left;">从左到右</td></tr><tr><td style="text-align:left;">一元</td><td style="text-align:left;">++expr、--expr、+、-、～、!</td><td style="text-align:left;">从右到左</td></tr><tr><td style="text-align:left;">乘性</td><td style="text-align:left;">*、/、％</td><td style="text-align:left;">左到右</td></tr><tr><td style="text-align:left;">加性</td><td style="text-align:left;">+、-</td><td style="text-align:left;">左到右</td></tr><tr><td style="text-align:left;">移位</td><td style="text-align:left;">&gt;&gt;、&gt;&gt;&gt;、&lt;&lt;</td><td style="text-align:left;">左到右</td></tr><tr><td style="text-align:left;">关系</td><td style="text-align:left;">&gt;、&gt;=、&lt;、&lt;=</td><td style="text-align:left;">左到右</td></tr><tr><td style="text-align:left;">相等</td><td style="text-align:left;">==、!=</td><td style="text-align:left;">左到右</td></tr><tr><td style="text-align:left;">按位与</td><td style="text-align:left;">＆</td><td style="text-align:left;">左到右</td></tr><tr><td style="text-align:left;">按位异或</td><td style="text-align:left;">^</td><td style="text-align:left;">左到右</td></tr><tr><td style="text-align:left;">按位或</td><td style="text-align:left;">|</td><td style="text-align:left;">左到右</td></tr><tr><td style="text-align:left;">逻辑与</td><td style="text-align:left;">&amp;&amp;</td><td style="text-align:left;">左到右</td></tr><tr><td style="text-align:left;">逻辑或</td><td style="text-align:left;">||</td><td style="text-align:left;">左到右</td></tr><tr><td style="text-align:left;">条件</td><td style="text-align:left;">?:</td><td style="text-align:left;">从右到左</td></tr><tr><td style="text-align:left;">赋值</td><td style="text-align:left;">=、+=、-=、*= 、/=、％=、&gt;&gt;=、&lt;&lt;=、＆=、^=、|=</td><td style="text-align:left;">从右到左</td></tr><tr><td style="text-align:left;">逗号</td><td style="text-align:left;">,</td><td style="text-align:left;">左到右</td></tr></tbody></table><hr>',35),C=(0,n.Uk)("参考："),A={href:"https://www.runoob.com/java/java-operators.html",target:"_blank",rel:"noopener noreferrer"},J=(0,n.Uk)("Java 运算符"),B=(0,n.uE)('<h2 id="包命名规则" tabindex="-1"><a class="header-anchor" href="#包命名规则" aria-hidden="true">#</a> 包命名规则</h2><ul><li><code>java.*</code>：Java 的核心包</li><li><code>javax.*</code>：扩展包，<code>x</code> 是 extension 的意思，也就是扩展。</li><li><code>org.*</code>：各个机构或组织发布的包，因为这些组织很有影响力，它们的代码质量很高，所以也将它们开发的部分常用的类随JDK一起发布。</li></ul><p>在包的命名方面，为了防止重名，有一个惯例：大家都以自己域名的倒写形式作为开头来为自己开发的包命名。例如百度发布的包会以 <code>com.baidu.*</code> 开头，W3C 组织发布的包会以 <code>org.w3c.*</code> 开头。</p><p>组织机构的域名后缀一般为 <code>org</code>，公司的域名后缀一般为 <code>com</code>，可以认为 <code>org.*</code> 开头的包为非盈利组织机构发布的包，它们一般是开源的，可以免费使用在自己的产品中，不用考虑侵权问题。而以 <code>com.*</code> 开头的包往往由盈利性的公司发布，可能会有版权问题，使用时要注意。</p><h2 id="关键字" tabindex="-1"><a class="header-anchor" href="#关键字" aria-hidden="true">#</a> 关键字</h2><h3 id="java中常见的关键字" tabindex="-1"><a class="header-anchor" href="#java中常见的关键字" aria-hidden="true">#</a> Java中常见的关键字</h3><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td>类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td></td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td></td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td>null</td><td>true</td><td>false</td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="访问权限修饰符" tabindex="-1"><a class="header-anchor" href="#访问权限修饰符" aria-hidden="true">#</a> 访问权限修饰符</h3><table><thead><tr><th>修饰符</th><th>当前类</th><th>同包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>protected</td><td>✔</td><td>✔</td><td>✔</td><td>🚫</td></tr><tr><td>空</td><td>✔</td><td>✔</td><td>🚫</td><td>🚫</td></tr><tr><td>private</td><td>✔</td><td>🚫</td><td>🚫</td><td>🚫</td></tr></tbody></table><h3 id="final" tabindex="-1"><a class="header-anchor" href="#final" aria-hidden="true">#</a> final</h3><h4 id="_1-修饰变量" tabindex="-1"><a class="header-anchor" href="#_1-修饰变量" aria-hidden="true">#</a> 1.修饰变量</h4><p>声明变量为<strong>常量</strong>，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token comment">// i = 2; //编译报错：Cannot assign a value to final variable &#39;i&#39;</span>\n<span class="token keyword">final</span> <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\na<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_2-修饰方法" tabindex="-1"><a class="header-anchor" href="#_2-修饰方法" aria-hidden="true">#</a> 2.修饰方法</h4><p>声明方法不能被子类重写。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><h4 id="_3-修饰类" tabindex="-1"><a class="header-anchor" href="#_3-修饰类" aria-hidden="true">#</a> 3.修饰类</h4><p>声明类不允许被继承。</p><h3 id="static" tabindex="-1"><a class="header-anchor" href="#static" aria-hidden="true">#</a> static</h3><h4 id="_1-修饰成员变量和方法" tabindex="-1"><a class="header-anchor" href="#_1-修饰成员变量和方法" aria-hidden="true">#</a> 1.修饰成员变量和方法</h4><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有的对象共享，可通过类名调用。被 static 声明的成员变量属于静态变量成员，静态变量存放在 Java 内存区域的方法区。</p><ul><li><p>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。</p></li><li><p>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</p></li><li><p>静态方法：不能访问非静态成员，方法中不能有 <code>this</code> 和 <code>super</code> 关键字。静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法(abstract)。</p></li></ul><h4 id="_2-静态代码块" tabindex="-1"><a class="header-anchor" href="#_2-静态代码块" aria-hidden="true">#</a> 2.静态代码块</h4><p>静态代码块在非静态代码块之前执行。执行先后顺序：静态代码块 -&gt; 非静态代码块 -&gt; 构造方法。该类不管创建多少对象，静态代码块只执行一次。</p><p>静态代码块与非静态代码块比较：</p><ul><li>相同点： 都是在 JVM 加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些 static 变量进行赋值。</li><li>不同点： 静态代码块在非静态代码块之前执行。静态代码块只在第一次 new 执行一次，之后不再执行；而非静态代码块在每 new 一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。</li></ul><h4 id="_3-静态内部类" tabindex="-1"><a class="header-anchor" href="#_3-静态内部类" aria-hidden="true">#</a> 3.静态内部类</h4><p>静态内部类和非静态内部类之间最大的一个区别在于：非静态内部类在编译完成之后会隐含地保存一个引用，该引用是指向创建它的外部类，但是静态内部类却没有。</p><p>没有这个引用就意味着：</p><ol><li>静态内部类的创建不需要依赖外围类的创建</li><li>静态内部类不能使用任何外部类的非 static 成员变量和方法</li></ol><h4 id="_4-静态导包" tabindex="-1"><a class="header-anchor" href="#_4-静态导包" aria-hidden="true">#</a> 4.静态导包</h4><p>格式 <code>import static</code>，可以导入指定类中的静态变量，1.5 之后的新特性。在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><h3 id="this" tabindex="-1"><a class="header-anchor" href="#this" aria-hidden="true">#</a> this</h3><p>this 关键字返回当前对象的引用。this 关键字只能在非静态方法内部使用。</p><p>建议 this 关键字只用在一些必须显式使用当前对象引用的特殊场合。例如，用在 return 语句中返回对当前对象的引用。</p><h3 id="super" tabindex="-1"><a class="header-anchor" href="#super" aria-hidden="true">#</a> super</h3><p>super 关键字用于子类访问父类的变量和方法。</p><blockquote><p>在构造方法中，通过 this、super 关键字调用其他构造方法时，必须放在第一行，否则编译器会报错。且在构造方法中，只能通过 this、super 调用一次其他构造方法。</p></blockquote><h2 id="反射" tabindex="-1"><a class="header-anchor" href="#反射" aria-hidden="true">#</a> 反射</h2><p>反射：运行时分析类以及执行类中方法的能力，通过反射可以获取任意一个类的所有属性和方法，并且可以显式的调用这些方法和属性。</p><p>Java 中的反射首先是能够获取到 Java 中要反射类的字节码，然后将字节码中的方法、变量、构造函数等映射成相应的 Method、Filed、Constructor 等类，这些类提供了丰富的方法可以被我们所使用。</p><p><code>Class</code> 和 <code>java.lang.reflect</code> 一起对反射提供了支持，<code>java.lang.reflect</code> 类库主要包含了以下三个类:</p><ul><li><strong>Field</strong> : 可以使用 <code>get()</code> 和 <code>set()</code> 方法读取和修改 Field 对象关联的字段；</li><li><strong>Method</strong> : 可以使用 <code>invoke()</code> 方法调用与 Method 对象关联的方法；</li><li><strong>Constructor</strong> : 可以用 Constructor 创建新的对象。</li></ul><hr>',45),_={href:"https://www.sczyh30.com/posts/Java/java-reflection-1/",target:"_blank",rel:"noopener noreferrer"},E=(0,n.Uk)("深入解析Java反射（1） - 基础"),S=(0,n.uE)('<h2 id="异常" tabindex="-1"><a class="header-anchor" href="#异常" aria-hidden="true">#</a> 异常</h2><p>Throwable 是 Java 语言中所有错误和异常的超类，可以用来表示任何可以作为异常抛出的类。它有两个子类: <strong>Error</strong> 和 <strong>Exception</strong>。</p><ul><li>Error 用来表示 JVM 无法处理的错误；</li><li>Exception 分为两种： <ul><li>检查性异常：除了 Error 和 RuntimeException 的其它异常。Javac 强制要求程序员为这样的异常做预备处理工作（使用 try…catch…finally 或者 throws）。在方法中要么用 try-catch 语句捕获它并处理，要么用throws 声明抛出它，否则编译不会通过；</li><li>运行时异常：是程序运行时错误，例如 除0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul></li></ul><p><img src="//gcore.jsdelivr.net/gh/tiancixiong/atips@img-230529/images/java/basic/throwable.png" alt="异常的结构"></p><h2 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型" aria-hidden="true">#</a> 泛型</h2><p>Java 泛型(generics)是 JDK 5 中引入的一个新特性，泛型提供了<strong>编译时类型安全检测机制</strong>，该机制允许程序员在编译时检测到非法的类型。泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><h3 id="常用的通配符" tabindex="-1"><a class="header-anchor" href="#常用的通配符" aria-hidden="true">#</a> 常用的通配符</h3><p>Java 中常用的通配符有：T，E，K，V，？</p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h2 id="枚举" tabindex="-1"><a class="header-anchor" href="#枚举" aria-hidden="true">#</a> 枚举</h2><p>Enum 全称 Enumeration 即枚举，是 Java 1.5 中引入的新特性。一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。</p><p>Enum 与 Class、Interface 具有相同地位。 可以继承多个接口， 可以拥有构造器、成员方法、成员变量。</p><p>枚举类与普通类不同之处：</p><ul><li>枚举类默认继承 <code>java.lang.Enum</code> 类，所以不能继承其他父类；</li><li>枚举类默认使用 final 修饰，因此不能派生子类；</li><li>枚举类构造器默认使用 private 修饰，且只能使用 private 修饰；</li><li>枚举类所有实例必须在第一行给出，默认添加 public static final 修饰，否则无法产生实例。</li></ul><hr>',15),I={href:"https://www.cnblogs.com/jingmoxukong/p/6098351.html",target:"_blank",rel:"noopener noreferrer"},q=(0,n.Uk)("Java 枚举"),U={href:"https://blog.csdn.net/qq_27093465/article/details/52180865",target:"_blank",rel:"noopener noreferrer"},T=(0,n.Uk)("Java 枚举(enum) 详解7种常见的用法"),W={},D=(0,a(3744).Z)(W,[["render",function(t,e){const a=(0,n.up)("OutboundLink");return(0,n.wg)(),(0,n.iD)(n.HY,null,[s,(0,n._)("blockquote",null,[(0,n._)("p",null,[l,(0,n._)("a",d,[r,(0,n.Wm)(a)]),i,(0,n._)("a",o,[c,(0,n.Wm)(a)]),p])]),u,(0,n._)("ul",null,[(0,n._)("li",null,[(0,n._)("a",h,[g,(0,n.Wm)(a)]),f]),(0,n._)("li",null,[(0,n._)("a",b,[k,(0,n.Wm)(a)]),y])]),x,(0,n._)("ul",null,[(0,n._)("li",null,[(0,n._)("a",m,[v,(0,n.Wm)(a)]),w])]),j,(0,n._)("p",null,[C,(0,n._)("a",A,[J,(0,n.Wm)(a)])]),B,(0,n._)("ul",null,[(0,n._)("li",null,[(0,n._)("a",_,[E,(0,n.Wm)(a)])])]),S,(0,n._)("ul",null,[(0,n._)("li",null,[(0,n._)("a",I,[q,(0,n.Wm)(a)])]),(0,n._)("li",null,[(0,n._)("a",U,[T,(0,n.Wm)(a)])])])],64)}]])},3744:(t,e)=>{e.Z=(t,e)=>{for(const[a,n]of e)t[a]=n;return t}}}]);