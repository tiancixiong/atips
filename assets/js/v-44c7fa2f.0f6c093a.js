"use strict";(self.webpackChunkatips=self.webpackChunkatips||[]).push([[1932],{4184:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-44c7fa2f",path:"/java/container/collection/java-collection-linkedlist.html",title:"Collection - LinkedList",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"概述",slug:"概述",children:[]},{level:2,title:"数据结构",slug:"数据结构",children:[]},{level:2,title:"构造函数",slug:"构造函数",children:[]},{level:2,title:"插入",slug:"插入",children:[{level:3,title:"头插",slug:"头插",children:[]},{level:3,title:"尾插",slug:"尾插",children:[]},{level:3,title:"中间插",slug:"中间插",children:[]}]},{level:2,title:"删除",slug:"删除",children:[{level:3,title:"删除操作方法",slug:"删除操作方法",children:[]},{level:3,title:"源码",slug:"源码",children:[]}]},{level:2,title:"查询",slug:"查询",children:[]},{level:2,title:"参考资料",slug:"参考资料",children:[]}],filePathRelative:"java/container/collection/java-collection-linkedlist.md",git:{updatedTime:1719836412e3,contributors:[{name:"Tianci.Xiong",email:"tiancixiong@163.com",commits:3},{name:"TianCi.Xiong",email:"tiancixiong@163.com",commits:2}]}}},930:(n,s,a)=>{a.r(s),a.d(s,{default:()=>i});var e=a(6252);const p=(0,e.uE)('<h1 id="collection-linkedlist" tabindex="-1"><a class="header-anchor" href="#collection-linkedlist" aria-hidden="true">#</a> Collection - LinkedList</h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p><em>LinkedList</em> 同时实现了 <em>List</em> 接口和 <em>Deque</em> 接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(<em>Queue</em>)，同时又可以看作一个栈(<em>Stack</em>)。这样看来，<em>LinkedList</em> 简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用 <em>LinkedList</em>，一方面是因为 Java 官方已经声明不建议使用 <em>Stack</em> 类，更遗憾的是，Java 里根本没有一个叫做 <em>Queue</em> 的类（它是个接口名字）。关于栈或队列，现在的首选是 <em>ArrayDeque</em>，它有着比 <em>LinkedList</em> （当作栈或队列使用时）有着更好的性能。</p><h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h2><p><img src="//gcore.jsdelivr.net/gh/tiancixiong/atips@img-230529/images/java/container/collection/image-20211020193901436.png" alt="image-20211020193901436"></p><p><em>LinkedList</em> 底层<strong>通过双向链表实现</strong>。由双向链条 <strong>next</strong>、<strong>prev</strong>，把数据节点穿插起来。所以，在插入数据时，是不需要像我们上一章节介绍的 <em>ArrayList</em> 那样，扩容数组。</p><p>双向链表的每个节点用内部类 <em><strong>Node</strong></em> 表示。<em>LinkedList</em> 通过 <code>first</code> 和 <code>last</code> 引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候 <code>first</code> 和 <code>last</code> 都指向 <code>null</code>。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">;</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>\n    <span class="token keyword">extends</span> <span class="token class-name">AbstractSequentialList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>\n    <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>\n<span class="token punctuation">{</span>\n    <span class="token comment">//... </span>\n    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>\n    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>\n\n    <span class="token comment">// Node 是私有的内部类</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>\n        <span class="token class-name">E</span> item<span class="token punctuation">;</span>\n        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>\n        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span>\n\n        <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p><img src="//gcore.jsdelivr.net/gh/tiancixiong/atips@img-230529/images/java/container/collection/linkedlist-base.png" alt="image-20211020193139419"></p><h2 id="构造函数" tabindex="-1"><a class="header-anchor" href="#构造函数" aria-hidden="true">#</a> 构造函数</h2><p>与 ArrayList 不同，<em>LinkedList</em> 初始化不需要创建数组，因为它是一个链表结构。而且也没有提供设置初始长度的构造器。<em>LinkedList</em> 只提供了 2 种构造函数：</p><ul><li><code>LinkedList()</code></li><li><code>LinkedList(Collection&lt;? extends E&gt; c)</code></li></ul><h2 id="插入" tabindex="-1"><a class="header-anchor" href="#插入" aria-hidden="true">#</a> 插入</h2><p><em>LinkedList</em> 的插入方法比较多，List 中接口中默认提供的是 <code>add()</code>，也可以指定位置插入。但在 <em>LinkedList</em> 中还提供了头插 <code>addFirst()</code> 和尾插 <code>addLast()</code>（<code>add()</code> 和 <code>addLast()</code> 作用相同） 。</p><h3 id="头插" tabindex="-1"><a class="header-anchor" href="#头插" aria-hidden="true">#</a> 头插</h3><p>先来看一张数据结构对比图，回顾下 ArrayList 的插入也和 LinkedList 插入做下对比，如下：</p><p><img src="//gcore.jsdelivr.net/gh/tiancixiong/atips@img-230529/images/java/container/collection/image-20211020200627443.png" alt="image-20211020200627443"></p><ul><li><em><strong>ArrayList</strong></em> 头插时，需要把数组元素通过 <code>Arrays.copyOf</code> 的方式把数组元素移位，如果容量不足还需要扩容；</li><li><em><strong>LinkedList</strong></em> 头插时，则不需要考虑扩容以及移位问题，直接把元素定位到首位，接点链条链接上即可。</li></ul><p><em>LinkedList</em> 中 <code>addFirst()</code> 方法调用了 <code>linkFirst()</code> 方法实现头插，源码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// java.util.LinkedList</span>\n<span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>\n<span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>\n\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">linkFirst</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>\n    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span> <span class="token comment">//first == last == null</span>\n    <span class="token keyword">else</span>\n        f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>\n    size<span class="token operator">++</span><span class="token punctuation">;</span>\n    modCount<span class="token operator">++</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><ul><li><code>first</code> 首节点会一直被记录，这样就非常方便头插；</li><li>插入时候会创建新的节点元素 <code>new Node&lt;&gt;(null, e, f)</code>，紧接着把新的头元素赋值给 <code>first</code>；</li><li>之后判断 <code>f</code> 节点（标记的 old first 节点）是否存在： <ul><li>不存在（<code>f == null</code>）则把头插节点 newNode 即作为第一个节点又作为最后一个节点；这种情况就是插入第一个元素时 first 和 last 都指向这个元素；</li><li>存在则用 <code>f</code> 节点的上一个链条 <code>f.prev</code> 链接 newNode；</li></ul></li><li>最后记录 <code>size</code> 大小，和元素数量 <code>modCount</code> 。 <code>modCount</code> 用在遍历时做校验 <code>modCount != expectedModCount</code>。</li></ul><h3 id="尾插" tabindex="-1"><a class="header-anchor" href="#尾插" aria-hidden="true">#</a> 尾插</h3><p>先来看一张数据结构对比图，回顾下 ArrayList 的插入也和 LinkedList 插入做下对比，如下：</p><p><img src="//gcore.jsdelivr.net/gh/tiancixiong/atips@img-230529/images/java/container/collection/image-20211020201922021.png" alt="image-20211020201922021"></p><ul><li><em>ArrayList</em> 尾插时，是不需要数据位移的，比较耗时的是数据的扩容时，需要拷贝迁移；</li><li><em>LinkedList</em> 尾插时，与头插相比耗时点会在对象的实例化上。</li></ul><p><em>LinkedList</em> 中 <code>add()</code> 和 <code>addLast()</code> 都是调用了 <code>linkLast()</code> 方法实现尾插，源码：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// java.util.LinkedList</span>\n<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>\n    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>\n    <span class="token keyword">else</span>\n        l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>\n    size<span class="token operator">++</span><span class="token punctuation">;</span>\n    modCount<span class="token operator">++</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ul><li>与头插代码相比几乎没有什么区别，只是 <code>first</code> 换成 <code>last</code>；</li><li>耗时点只是在创建节点上 <code>new Node&lt;E&gt;</code>。</li></ul><h3 id="中间插" tabindex="-1"><a class="header-anchor" href="#中间插" aria-hidden="true">#</a> 中间插</h3><p>先来看一张数据结构对比图，回顾下 ArrayList 的插入也和 LinkedList 插入做下对比，如下：</p><p><img src="//gcore.jsdelivr.net/gh/tiancixiong/atips@img-230529/images/java/container/collection/image-20211020203555056.png" alt="image-20211020203555056"></p><ul><li><em>ArrayList</em> 中间插入，首先我们知道他的定位时间复杂度是 O(1)，比较耗时的点在于数据迁移和容量不足的时候扩容；</li><li><code>LinkedList</code> 中间插入，链表的数据实际插入时候并不会怎么耗时，但是它定位元素的时间复杂度是 O(n) ，所以这部分以及元素的实例化比较耗时。</li></ul><hr><p>看下 <code>LinkedList</code> 指定位置插入的源码：</p><p>使用 <code>add(索引, 元素)</code> 方法插入：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// java.util.LinkedList</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span>\n        <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">else</span>\n        <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>其中，使用 <code>node(index)</code> 进行位置定位：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// java.util.LinkedList</span>\n<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// assert isElementIndex(index);</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>\n            x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n        <span class="token keyword">return</span> x<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>\n            x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>\n        <span class="token keyword">return</span> x<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ul><li><code>size &gt;&gt; 1</code> ，这部分的代码判断元素位置在左半区间，还是右半区间，在进行循环查找。</li></ul><p>通过 <code>linkLast()</code> 和 <code>linkBefore()</code> 执行插入的操作：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// java.util.LinkedList</span>\n<span class="token keyword">void</span> <span class="token function">linkBefore</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> succ<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// assert succ != null;</span>\n    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>\n    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> succ<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>\n    <span class="token keyword">else</span>\n        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>\n    size<span class="token operator">++</span><span class="token punctuation">;</span>\n    modCount<span class="token operator">++</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li>找到指定位置后插入的过程就比较简单了，与头插、尾插，相差不大；</li><li>整个过程可以看到，插入中比较耗时的点会在遍历寻找插入位置上。</li></ul><h2 id="删除" tabindex="-1"><a class="header-anchor" href="#删除" aria-hidden="true">#</a> 删除</h2><p><em>ArrayList</em> 不同，<em>LinkedList</em> 删除不需要拷贝元素，它是找到元素位置，把元素前后链连接上。基本如下图；</p><p><img src="//gcore.jsdelivr.net/gh/tiancixiong/atips@img-230529/images/java/container/collection/image-20211020204657478.png" alt="image-20211020204657478"></p><ul><li>确定出要删除的元素 <code>x</code> ，把前后的链接进行替换；</li><li>如果是删除首尾元素，操作起来会更加容易，这也就是为什么说插入和删除快。但中间位置删除，需要遍历找到对应位置。</li></ul><h3 id="删除操作方法" tabindex="-1"><a class="header-anchor" href="#删除操作方法" aria-hidden="true">#</a> 删除操作方法</h3><p><em>LinkedList</em> 提供了丰富的删除操作，具体如下：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>E remove()</code></td><td>与 <code>removeFirst()</code> 一致</td></tr><tr><td><code>E remove(int index)</code></td><td>删除指定位置元素节点，需要遍历定位元素位置</td></tr><tr><td><code>boolean remove(Object o)</code></td><td>删除第一个与 o 匹配上的节点，需要遍历定位</td></tr><tr><td><code>E removeFirst()</code></td><td>删除首位节点</td></tr><tr><td><code>E removeLast()</code></td><td>删除结尾节点</td></tr><tr><td><code>boolean removeFirstOccurrence(Object o)</code></td><td>删除第一个匹配上的元素（从头到尾遍历列表）</td></tr><tr><td><code>boolean removeLastOccurrence(Object o)</code></td><td>删除最后一个匹配上的元素（从头到尾遍历列表）</td></tr></tbody></table><p>还有继承自父类（<em>AbstractCollection</em>）的方法：<code>boolean removeAll(Collection&lt;?&gt; c)</code>，按照集合批量删除，底层是 <em>Iterator</em> 删除。</p><h3 id="源码" tabindex="-1"><a class="header-anchor" href="#源码" aria-hidden="true">#</a> 源码</h3><p>删除操作的源码都差不多，分为删除首尾节点与其他节点时候，对节点的解链操作。这里我们举一个如 <code>list.remove(&quot;a&quot;);</code> 删除其他位置的源码进行学习，如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// java.util.LinkedList</span>\n<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>这一部分是元素定位，和 <code>unlink(x)</code> 解链；循环查找对应的元素。</p><p><code>unlink(x)</code> 解链：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// java.util.LinkedList</span>\n<span class="token class-name">E</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// assert x != null;</span>\n    <span class="token keyword">final</span> <span class="token class-name">E</span> element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>\n    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        first <span class="token operator">=</span> next<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>\n        x<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        last <span class="token operator">=</span> prev<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>\n        x<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    x<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    size<span class="token operator">--</span><span class="token punctuation">;</span>\n    modCount<span class="token operator">++</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> element<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><ol><li>获取待删除元素节点 <code>item</code> 的信息；元素下一个节点 <code>next</code> 、元素上一个节点 <code>prev</code>；</li><li>如果 <code>prev</code> 节点为空（说明待删除元素为头元素）则把待删除元素 <code>x</code> 的下一个节点 <code>next</code> 赋值给首节点 <code>first</code>；否则把待删除节点的下一个节点 <code>next</code>，赋值给待删除节点的上一个节点的子节点 <code>prev.next</code>。并将 <code>x</code> 节点的向前指向置为空：<code>x.prev = null</code>；</li><li>如果 <code>next</code> 节点为空（说明但删除元素为尾元素）则把把待删除元素 <code>x</code> 的上一个节点 <code>prev</code> 赋值给尾节点 <code>last</code>；否则把待删除节点的上一个节点 <code>prev</code>，赋值给待删除节点的下一个节点的子节点 <code>next.prev</code>。并将 <code>x</code> 节点的向后指向置为空：<code>x.next = null</code>；</li><li>通过步骤2和步骤3后，就将待删除节点 <code>x</code> 从链表中分离出来了，<code>x</code> 节点和链表上的其他节点已经没有了关联关系；</li><li>最后就是把删除节点 <code>x</code> 置空：<code>x.item = null;</code> ，并扣减 <code>size</code> 和增加 <code>modeCount</code> 数量。</li></ol><h2 id="查询" tabindex="-1"><a class="header-anchor" href="#查询" aria-hidden="true">#</a> 查询</h2><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// java.util.LinkedList</span>\n<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// assert isElementIndex(index);</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>\n            x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>\n        <span class="token keyword">return</span> x<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>\n            x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>\n        <span class="token keyword">return</span> x<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>上述代码，利用了双向链表的特性，如果 <code>index</code> 离链表头比较近，就从节点头部遍历。否则就从节点尾部开始遍历。使用空间（双向链表）来换取时间。</p><ul><li><code>node()</code> 会以 O(n/2) 的性能去获取一个结点</li><li>如果索引值大于链表大小的一半，那么将从尾结点开始遍历</li></ul><p>这样的效率是非常低的，特别是当 index 越接近 size 的中间值时。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',63),t=(0,e._)("li",null,"《Java 面经手册》- 小傅哥",-1),o={href:"https://www.cnblogs.com/CarpenterLee/p/5457150.html",target:"_blank",rel:"noopener noreferrer"},c=(0,e.Uk)("Java LinkedList源码剖析"),l={},i=(0,a(3744).Z)(l,[["render",function(n,s){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.iD)(e.HY,null,[p,(0,e._)("ul",null,[t,(0,e._)("li",null,[(0,e._)("a",o,[c,(0,e.Wm)(a)])])])],64)}]])},3744:(n,s)=>{s.Z=(n,s)=>{for(const[a,e]of s)n[a]=e;return n}}}]);